module.exports = Model;

const log = require('debug')('pouchdb-model');
const noopValidation = input => Promise.resolve(input);

function Model(db, { createId, indexes, migrations }, validate) {
  this._createId = createId;
  this.db = db;
  this.indexes = indexes;
  this.validate = validate || noopValidation;
  this.migrations = migrations;
}

Model.prototype.createId = function(data) {
  if (data._id) {
    return data._id;
  } else {
    return this._createId(data);
  }
};

Model.prototype.onNotFound = function(err, fn) {
  if (err.status === 404) {
    return fn();
  } else {
    throw err;
  }
};

Model.prototype.findById = function(id) {
  return this.db.get(id);
};

Model.prototype.findOne = function(data) {
  return this.db.get(this.createId(data));
};

Model.prototype.findOneOrInit = function(id, init) {
  return this
    .findOne(id)
    .then(null, err => this.onNotFound(err, init));
};

function flattenDocs(res) {
  return res.rows.map(row => ({
    ...row.doc,
    _key: row.key
  }));
}

Model.prototype.findByIndexRaw = function(index, options = {}, omitNormalization) {
  return this.db
    .query(index,
      omitNormalization ?
        options :
        this.normalizeOptions({ include_docs: true, ...options }, true)
    );
};

Model.prototype.findByIndex = function(index, options = {}, omitNormalization) {
  return this
    .findByIndexRaw(index, options, omitNormalization)
    .then(res => flattenDocs(res));
};

Model.prototype.findAllRaw = function(options = {}, omitNormalization) {
  return this.db
    .allDocs(
      omitNormalization ?
        options :
        this.normalizeOptions({ include_docs: true, ...options })
    );
};

Model.prototype.findAll = function(options = {}, omitNormalization) {
  return this.findAllRaw(options, omitNormalization)
    .then(res => flattenDocs(res));
};

/*
 * https://pouchdb.com/2014/04/14/pagination-strategies-with-pouchdb.html
 * https://stackoverflow.com/questions/25728903/pouchdb-exclude-design-documents-when-using-autogenerated-uuid
 */
Model.prototype.normalizeOptions = function(options, omitDesignDocsHack) {
  if (('key' in options) || ('keys' in options)) {
    return options;
  }

  let { startkey, endkey, since, ...filteredOptions } = options;

  if ('startkey' in options) {
    startkey = options.startkey;
  } else if (!options.descending) {
    startkey = since || (omitDesignDocsHack ? undefined : '_design\uffff');
  } else {
    startkey = since;
  }

  if ('endkey' in options) {
    endkey = options.endkey;
  } else if (!options.descending) {
    endkey = undefined;
  } else {
    endkey = omitDesignDocsHack ? undefined : '_design\uffff';
  }

  const skip = since ? 1 : 0;

  return {
    skip,
    startkey,
    endkey,
    ...filteredOptions
  };
};

Model.prototype.normalizeDoc = function(data) {
  const doc = {
    ...data,
    _id: this.createId(data),
    updatedAt: new Date().toISOString()
  };

  if (!doc.createdAt) {
    doc.createdAt = doc.updatedAt;
  }

  if ('_key' in doc) {
    delete doc._key;
  }

  return doc;
};

Model.prototype.put = function(data) {
  const doc = this.normalizeDoc(data);

  return this
    .validate(doc)
    .then(doc => this.db.put(doc))
    .then(result => { // Object.keys(result) //=> ['ok', 'id', 'rev']
      doc._rev = result.rev;
      return doc;
    });
};

Model.prototype.update = function(data) {
  return this
    .findOne(data)
    .then(
      dbData => {
        const obj = { ...dbData, ...data };
        obj._rev = dbData._rev;
        return this.put(obj);
      },
      err => this.onNotFound(err, () => {
        return this.put(data);
      })
    );
};

Model.prototype.bulk = function(docs) {
  const errors = [];
  const correct = [];

  return Promise
    .all(
      docs.map((doc, index) => this.validate(doc).then(
        doc => correct.push({ doc, index }),
        err => errors.push({
          err: {
            error: true,
            name: 'validation error',
            err
          },
          doc,
          index
        })
      ))
    )
    .then(() => {
      const docs = correct.map(item => {
        item.doc = this.normalizeDoc(item.doc);
        return item.doc;
      });

      return this.db.bulkDocs(docs);
    })
    .then(dbDocs => {
      let correctIndex = 0;
      let errorsIndex = 0;
      let dbIndex = 0;

      return docs.map((_, index) => {
        let doc;
        let dbDoc;

        if (correct[correctIndex] && correct[correctIndex].index === index) {
          doc = correct[correctIndex].doc;
          dbDoc = dbDocs[dbIndex];

          correctIndex++;
          dbIndex++;
        } else if (errors[errorsIndex] && errors[errorsIndex].index === index) {
          doc = errors[errorsIndex].doc;
          dbDoc = errors[errorsIndex].err;

          errorsIndex++;
        }

        if (dbDoc.ok === true) {
          return {
            ...doc,
            _id: dbDoc.id,
            _rev: dbDoc.rev
          };
        }

        return dbDoc;
      });
    });
};

/*
 * https://pouchdb.com/api.html#sync
 */
Model.prototype.sync = function(db, options, notify) {
  if (!notify && typeof options === 'function') {
    notify = options;
    options = {};
  }

  return new Promise((resolve, reject) => {
    this.db
      .sync(db, options)
      .on('change', info => {
        // handle change // info.doc_read info.doc_written info.last_seq info.errors
        const message =
          `${capitalize(info.direction)}: ` +
          `${info.change.docs_read} read, ${info.change.docs_written} written`;

        notify('change', info, message);
      })
      .on('paused', err => {
        // replication paused (e.g. replication up to date, user went offline)
        notify('paused', err, 'Paused');
      })
      .on('active', () => {
        // replicate resumed (e.g. new changes replicating, user went back online)
        notify('action', null, 'Action');
      })
      .on('denied', err => {
        // a document failed to replicate, e.g. due to permissions
        notify('denied', err, 'Denied');
      })
      .on('complete', info => {
        // handle complete
        notify('complete', info, 'Complete');
        resolve();
      })
      .on('error', err => {
        notify('error', err, `Error: ${err.message}`);
        reject(err);
      });
  });
};

Model.prototype.createDesignDoc = function(name, mapFunction) {
  const ddoc = {
    _id: '_design/' + name,
    views: {}
  };

  ddoc.views[name] = { map: mapFunction.toString() };
  return ddoc;
};

Model.prototype.ensureIndexes = function() {
  if (!this.indexes) {
    return Promise.resolve();
  }

  const promises = this.indexes
    .map(({ name, fn }) => {
      const designDoc = this.createDesignDoc(name, fn);

      return this.db
        .put(designDoc)
        .then(() => {
          log(`${designDoc._id} has been created`);
        }, err => {
          if (err.name === 'conflict') {
            log(`${designDoc._id} already exists`);
          } else {
            throw err;
          }
        });
    });

  return Promise.all(promises);
};

Model.prototype.ensureMigrations = function() {
  const result = Promise.resolve();

  if (!this.migrations || this.migrations.length === 0) {
    return result;
  }

  if (!this.db.migrate) {
    return Promise.reject(`pouchdb-migrate is missing - PouchDB.plugin(require('pouchdb-migrate'))`);
  }

  return this.migrations.reduce((prev, migration, index) => {
    return prev.then(() => {
      log(`start migration ${index + 1} / ${this.migrations.length}`);

      return this.db
        .migrate(migration)
        .then(() => {
          log(`finish ${index + 1} / ${this.migrations.length}`);
        });
    });
  }, result);
};

function capitalize(str) {
  return str.slice(0, 1).toUpperCase() + str.slice(1);
}
